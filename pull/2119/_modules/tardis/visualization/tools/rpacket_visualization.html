<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tardis.visualization.tools.rpacket_visualization &mdash; tardis</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/plot_directive.css" type="text/css" />
    <link rel="shortcut icon" href="../../../../_static/tardis_logo.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href="../../../../_static/tardis.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> tardis
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart.html">Quickstart for TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/modules.html">API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Input/Output</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/configuration/index.html">Configuration (Required Input)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/optional/index.html">Optional Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/visualization/index.html">Visualization Tools &amp; Widgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/output/index.html">Additional Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/grid/TardisGridTutorial.html">Running TARDIS Model Grids</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Physics Walkthrough</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/intro/index.html">Physics Walkthrough Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/setup/index.html">Setting Up the Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/montecarlo/index.html">Monte Carlo Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/update_and_conv/update_and_conv.html">Updating Plasma and Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/spectrum/index.html">Spectrum Generation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing to TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/CONTRIBUTING.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/development/index.html">Developer Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/CHANGELOG.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/in_progress/index.html">Features In-Progress</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/credits.html">Credits &amp; Publication Policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/research_done_using_TARDIS/research_papers.html">Papers Using TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/code_comparison/index.html">Code Comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/zreferences.html">References and Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Outdated</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../outdated/index.html">Outdated Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">tardis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>tardis.visualization.tools.rpacket_visualization</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tardis.visualization.tools.rpacket_visualization</h1><div class="highlight"><pre>
<span></span>import math
import logging
import pandas as pd
import numpy as np
import astropy.units as u
import plotly.express as px
import plotly.graph_objects as go


<div class="viewcode-block" id="RPacketPlotter"><a class="viewcode-back" href="../../../../api/tardis.visualization.tools.rpacket_visualization.html#tardis.visualization.tools.rpacket_visualization.RPacketPlotter">[docs]</a>class RPacketPlotter:
    &quot;&quot;&quot;
    Plotting interface for the plotting Montecarlo packets. It creates an animated plot using plotly for the
    trajectories of the real packets as they travel through the ejecta starting from the photosphere.
    &quot;&quot;&quot;

    def __init__(self, sim, no_of_packets):
        &quot;&quot;&quot;
        Initializes the RPacket Plotter using the simulation object generated using the run_tardis function.

        Parameters
        ----------
        sim : tardis.simulation.Simulation
            simulation object generated using the run_tardis function.
        no_of_packets : int
            number of packets to be used for plotting.
        &quot;&quot;&quot;
        self.no_of_packets = no_of_packets
        self.sim = sim
        self.interaction_from_num = [
            {&quot;text&quot;: &quot;No Interaction&quot;, &quot;color&quot;: &quot;darkslategrey&quot;, &quot;opacity&quot;: 0},
            {&quot;text&quot;: &quot;e-Scattering&quot;, &quot;color&quot;: &quot;#3366FF&quot;, &quot;opacity&quot;: 1},
            {&quot;text&quot;: &quot;Line Interaction&quot;, &quot;color&quot;: &quot;#FF3300&quot;, &quot;opacity&quot;: 1},
        ]
        self.theme_colors = dict(
            light=dict(
                linecolor=&quot;#555&quot;,
                gridcolor=&quot;#fafafa&quot;,
                zerolinecolor=&quot;#fafafa&quot;,
                color=&quot;#000&quot;,
                photosphere_line_color=&quot;black&quot;,
                photosphere_fillcolor=&quot;darkgrey&quot;,
                shells_line_color=&quot;black&quot;,
                packet_line_color=&quot;darkslategrey&quot;,
                plot_bgcolor=&quot;#fafafa&quot;,
                paper_bgcolor=&quot;#fafafa&quot;,
                title_font_color=&quot;#444&quot;,
                legendgrouptitle_color=&quot;#444&quot;,
                button_bgcolor=&quot;#fafafa&quot;,
                button_font_color=&quot;#2A3F5F&quot;,
                slider_font_color=&quot;#2A3F5F&quot;,
                bordercolor=&quot;#BEC8D9&quot;,
                slider_bgcolor=&quot;#F8FAFC&quot;,
                slider_activebgcolor=&quot;#DBDDE0&quot;,
                slider_currentvalue_color=&quot;#2A3F5F&quot;,
                font_color=&quot;#000&quot;,
            ),
            dark=dict(
                linecolor=&quot;#050505&quot;,
                gridcolor=&quot;#111&quot;,
                zerolinecolor=&quot;#111&quot;,
                color=&quot;#fafafa&quot;,
                photosphere_line_color=&quot;#222&quot;,
                photosphere_fillcolor=&quot;#222&quot;,
                shells_line_color=&quot;#555&quot;,
                packet_line_color=&quot;#888&quot;,
                plot_bgcolor=&quot;#000&quot;,
                paper_bgcolor=&quot;#000&quot;,
                title_font_color=&quot;#ccc&quot;,
                legendgrouptitle_color=&quot;#ccc&quot;,
                button_bgcolor=&quot;#282828&quot;,
                button_font_color=&quot;#888&quot;,
                slider_font_color=&quot;#888&quot;,
                bordercolor=&quot;black&quot;,
                slider_bgcolor=&quot;#888&quot;,
                slider_activebgcolor=&quot;#fafafa&quot;,
                slider_currentvalue_color=&quot;#fff&quot;,
                font_color=&quot;#fafafa&quot;,
            ),
        )

<div class="viewcode-block" id="RPacketPlotter.from_simulation"><a class="viewcode-back" href="../../../../api/tardis.visualization.tools.rpacket_visualization.html#tardis.visualization.tools.rpacket_visualization.RPacketPlotter.from_simulation">[docs]</a>    @classmethod
    def from_simulation(cls, sim, no_of_packets=15):
        &quot;&quot;&quot;
        Creates an instance of RPacketPlotter from a TARDIS simulation object.

        Parameters
        ----------
        sim : tardis.simulation.Simulation
            TARDIS Simulation object generated using run_tardis function.
        no_of_packets : int
            number of packets to be used for plotting.

        Returns
        -------
        RPacketPlotter
        &quot;&quot;&quot;
        logger = logging.getLogger(__name__)
        if hasattr(sim.runner, &quot;rpacket_tracker_df&quot;):
            if sim.last_no_of_packets &gt;= no_of_packets:
                return cls(sim, no_of_packets)
            else:
                logger.warning(
                    &quot;&quot;&quot;
                no_of_packets specified are more than the actual no of packets in the model. Using all packets in the model.
                &quot;&quot;&quot;
                )
                return cls(sim, sim.last_no_of_packets)
        else:
            raise AttributeError(
                &quot;&quot;&quot; There is no attribute named rpacket_tracker in the simulation object passed. Try enabling the 
                rpacket tracking in the configuration. To enable rpacket tracking see: https://tardis-sn.github.io/tardis/io/output/rpacket_tracking.html#How-to-Setup-the-Tracking-for-the-RPackets?&quot;&quot;&quot;
            )</div>

<div class="viewcode-block" id="RPacketPlotter.generate_plot"><a class="viewcode-back" href="../../../../api/tardis.visualization.tools.rpacket_visualization.html#tardis.visualization.tools.rpacket_visualization.RPacketPlotter.generate_plot">[docs]</a>    def generate_plot(self, theme=&quot;light&quot;):
        &quot;&quot;&quot;
        Creates an animated plotly plot showing the Montecarlo packets&#39; trajectories.

        Parameters
        ----------
        theme : str, optional
            theme for the plot, by default &quot;light&quot;

        Returns
        -------
        plotly.graph_objs._figure.Figure
            plot containing the packets, photosphere and the shells.
        &quot;&quot;&quot;

        self.fig = go.Figure()

        # getting velocity of different shells
        v_shells = self.sim.model.velocity.to_value(u.km / u.s)

        # getting coordinates and interactions of all packets
        (
            rpacket_x,
            rpacket_y,
            rpacket_interactions,
        ) = self.get_coordinates_multiple_packets(
            self.sim.runner.rpacket_tracker_df.loc[0 : (self.no_of_packets)],
        )

        # making the coordinate arrays of all packets equal
        (
            rpacket_x,
            rpacket_y,
            rpacket_interactions,
            rpacket_array_max_size,
        ) = self.get_equal_array_size(
            rpacket_x, rpacket_y, rpacket_interactions
        )
        # Set axes properties
        self.fig.update_xaxes(
            scaleanchor=&quot;y&quot;,
            scaleratio=1,
            range=[-1.1 * v_shells[-1], 1.1 * v_shells[-1]],
            title=&quot;Velocity (km/s)&quot;,
            exponentformat=&quot;none&quot;,
            color=self.theme_colors[theme][&quot;color&quot;],
            linecolor=self.theme_colors[theme][&quot;linecolor&quot;],
            gridcolor=self.theme_colors[theme][&quot;gridcolor&quot;],
            zerolinecolor=self.theme_colors[theme][&quot;zerolinecolor&quot;],
        )
        self.fig.update_yaxes(
            range=[-1.1 * v_shells[-1], 1.1 * v_shells[-1]],
            title=&quot;Velocity (km/s)&quot;,
            exponentformat=&quot;none&quot;,
            color=self.theme_colors[theme][&quot;color&quot;],
            linecolor=self.theme_colors[theme][&quot;linecolor&quot;],
            gridcolor=self.theme_colors[theme][&quot;gridcolor&quot;],
            zerolinecolor=self.theme_colors[theme][&quot;zerolinecolor&quot;],
        )

        # adding the shells and photosphere
        for shell_no in range(len(self.sim.model.radius.value)):
            if shell_no == 0:
                # photosphere
                self.fig.add_shape(
                    type=&quot;circle&quot;,
                    xref=&quot;x&quot;,
                    yref=&quot;y&quot;,
                    x0=-1 * v_shells[shell_no],
                    y0=-1 * v_shells[shell_no],
                    x1=v_shells[shell_no],
                    y1=v_shells[shell_no],
                    line_color=self.theme_colors[theme][
                        &quot;photosphere_line_color&quot;
                    ],
                    fillcolor=self.theme_colors[theme][&quot;photosphere_fillcolor&quot;],
                    opacity=1,
                )
            elif shell_no == (len(self.sim.model.radius.value) - 1):
                # outermost shell
                self.fig.add_shape(
                    type=&quot;circle&quot;,
                    xref=&quot;x&quot;,
                    yref=&quot;y&quot;,
                    x0=-1 * v_shells[shell_no],
                    y0=-1 * v_shells[shell_no],
                    x1=v_shells[shell_no],
                    y1=v_shells[shell_no],
                    line_color=self.theme_colors[theme][&quot;shells_line_color&quot;],
                    opacity=1,
                )
            else:
                # remaining shells
                self.fig.add_shape(
                    type=&quot;circle&quot;,
                    xref=&quot;x&quot;,
                    yref=&quot;y&quot;,
                    x0=-1 * v_shells[shell_no],
                    y0=-1 * v_shells[shell_no],
                    x1=v_shells[shell_no],
                    y1=v_shells[shell_no],
                    line_color=self.theme_colors[theme][&quot;shells_line_color&quot;],
                    opacity=0.2,
                )

        # Adding packet trajectory

        for packet_no in range(len(rpacket_x)):
            self.fig.add_trace(
                go.Scatter(
                    x=rpacket_x[packet_no],
                    y=rpacket_y[packet_no],
                    mode=&quot;markers+lines&quot;,
                    name=&quot;Packet &quot; + str(packet_no + 1),
                    showlegend=False,
                    hovertemplate=&quot;&lt;b&gt;X&lt;/b&gt;: %{x}&quot;
                    + &quot;&lt;br&gt;&lt;b&gt;Y&lt;/b&gt;: %{y}&lt;br&gt;&quot;
                    + &quot;&lt;b&gt;Last Interaction: %{text}&lt;/b&gt;&quot;,
                    text=[
                        self.interaction_from_num[
                            int(rpacket_interactions[packet_no][step_no])
                        ][&quot;text&quot;]
                        for step_no in range(len(rpacket_x[packet_no]))
                    ],
                    line=dict(
                        color=self.theme_colors[theme][&quot;packet_line_color&quot;]
                    ),
                    marker=dict(
                        opacity=[
                            self.interaction_from_num[
                                int(rpacket_interactions[packet_no][step_no])
                            ][&quot;opacity&quot;]
                            for step_no in range(len(rpacket_x[packet_no]))
                        ],
                        color=[
                            self.interaction_from_num[
                                int(rpacket_interactions[packet_no][step_no])
                            ][&quot;color&quot;]
                            for step_no in range(len(rpacket_x[packet_no]))
                        ],
                    ),
                )
            )

        # adding legends
        self.fig.add_trace(
            go.Scatter(
                x=[9999999],
                y=[0],
                legendgroup=&quot;a&quot;,
                opacity=1,
                legendgrouptitle=dict(
                    font=dict(
                        color=self.theme_colors[theme][&quot;legendgrouptitle_color&quot;]
                    ),
                    text=&quot;Interaction Type:&quot;,
                ),
                mode=&quot;lines+markers&quot;,
                name=&quot;e-scattering&quot;,
                hoverlabel=dict(font=dict(color=&quot;#222&quot;)),
                marker=dict(color=&quot;#3366FF&quot;),
            )
        )
        self.fig.add_trace(
            go.Scatter(
                x=[9999999],
                y=[0],
                legendgroup=&quot;a&quot;,
                opacity=1,
                mode=&quot;lines+markers&quot;,
                name=&quot;Line Interaction&quot;,
                marker=dict(color=&quot;#FF3300&quot;),
            )
        )

        # Set figure size
        self.fig.layout.plot_bgcolor = self.theme_colors[theme][&quot;plot_bgcolor&quot;]
        self.fig.layout.paper_bgcolor = self.theme_colors[theme][
            &quot;paper_bgcolor&quot;
        ]

        self.fig.update_layout(
            width=890,
            height=700,
            title=&quot;Packet Trajectories&quot;,
            title_font_color=self.theme_colors[theme][&quot;title_font_color&quot;],
            font_color=self.theme_colors[theme][&quot;font_color&quot;],
            updatemenus=[
                dict(
                    type=&quot;buttons&quot;,
                    xanchor=&quot;right&quot;,
                    x=0.1,
                    y=0,
                    yanchor=&quot;top&quot;,
                    direction=&quot;left&quot;,
                    pad={&quot;r&quot;: 10, &quot;t&quot;: 87},
                    showactive=False,
                    bgcolor=self.theme_colors[theme][&quot;button_bgcolor&quot;],
                    bordercolor=self.theme_colors[theme][&quot;bordercolor&quot;],
                    font={
                        &quot;color&quot;: self.theme_colors[theme][&quot;button_font_color&quot;]
                    },
                    buttons=[
                        {
                            &quot;args&quot;: [
                                None,
                                {
                                    &quot;frame&quot;: {&quot;duration&quot;: 500, &quot;redraw&quot;: False},
                                    &quot;fromcurrent&quot;: True,
                                    &quot;transition&quot;: {
                                        &quot;duration&quot;: 300,
                                        &quot;easing&quot;: &quot;quadratic-in-out&quot;,
                                    },
                                },
                            ],
                            &quot;label&quot;: &quot;Play&quot;,
                            &quot;method&quot;: &quot;animate&quot;,
                        },
                        {
                            &quot;args&quot;: [
                                [None],
                                {
                                    &quot;frame&quot;: {&quot;duration&quot;: 0, &quot;redraw&quot;: False},
                                    &quot;mode&quot;: &quot;immediate&quot;,
                                    &quot;transition&quot;: {&quot;duration&quot;: 0},
                                },
                            ],
                            &quot;label&quot;: &quot;Pause&quot;,
                            &quot;method&quot;: &quot;animate&quot;,
                        },
                    ],
                )
            ],
        )

        # adding frames
        self.fig.frames = [
            go.Frame(
                data=self.get_frames(
                    frame, rpacket_x, rpacket_y, rpacket_interactions, theme
                ),
                name=frame,
            )
            for frame in range(rpacket_array_max_size + 1)
        ]

        # adding timeline slider
        self.fig.layout.sliders = [
            {
                &quot;active&quot;: 0,
                &quot;activebgcolor&quot;: self.theme_colors[theme][
                    &quot;slider_activebgcolor&quot;
                ],
                &quot;bgcolor&quot;: self.theme_colors[theme][&quot;slider_bgcolor&quot;],
                &quot;bordercolor&quot;: self.theme_colors[theme][&quot;bordercolor&quot;],
                &quot;yanchor&quot;: &quot;top&quot;,
                &quot;xanchor&quot;: &quot;left&quot;,
                &quot;currentvalue&quot;: {
                    &quot;font&quot;: {
                        &quot;color&quot;: self.theme_colors[theme][
                            &quot;slider_currentvalue_color&quot;
                        ],
                    },
                    &quot;prefix&quot;: &quot;Step:&quot;,
                    &quot;visible&quot;: True,
                    &quot;xanchor&quot;: &quot;right&quot;,
                },
                &quot;font&quot;: {
                    &quot;color&quot;: self.theme_colors[theme][&quot;slider_font_color&quot;]
                },
                &quot;transition&quot;: {&quot;duration&quot;: 300, &quot;easing&quot;: &quot;cubic-in-out&quot;},
                &quot;pad&quot;: {&quot;b&quot;: 10, &quot;t&quot;: 50},
                &quot;len&quot;: 0.9,
                &quot;x&quot;: 0.1,
                &quot;y&quot;: 0,
                &quot;steps&quot;: self.get_slider_steps(rpacket_array_max_size),
            }
        ]

        return self.fig</div>

<div class="viewcode-block" id="RPacketPlotter.get_coordinates_with_theta_init"><a class="viewcode-back" href="../../../../api/tardis.visualization.tools.rpacket_visualization.html#tardis.visualization.tools.rpacket_visualization.RPacketPlotter.get_coordinates_with_theta_init">[docs]</a>    def get_coordinates_with_theta_init(
        self,
        r_track,
        mu_track,
        time,
        last_interaction_type,
        theta_initial=0,
    ):
        &quot;&quot;&quot;
        Generates the coordinates of a single packet for its entire trajectory using the `nu` and `r` attributes.

        Parameters
        ----------
        r_track : pandas.core.series.Series
            radius of packet at different steps
        mu_track : pandas.core.series.Series
            mu or the cosine of radial angle of the packet at different steps
        time : astropy.units.quantity.Quantity
            time since the occurence of explosion
        last_interaction_type : pandas.core.series.Series
            last interaction type of the packet at different steps
        theta_initial : float, optional
            intial launch angle of packet from x axis as the packet starts from the photosphere, by default 0

        Returns
        -------
        list
            x coordinates of the packet at different steps
        list
            y coordinates of the packet at different steps
        list
            types of interactions occuring at different points
        &quot;&quot;&quot;
        rpacket_x, rpacket_y, theta, rpacket_interactions = [], [], [], []

        # getting thetas at different steps of the packet movement

        for step_no in range(len(r_track)):
            # for the first step the packet is at photosphere, so theta will be equal to the intial angle we are launching the packet from
            if step_no == 0:
                theta.append(theta_initial)
            # for further steps we calculate thetas with the formula derived in the documentation
            else:
                if r_track[step_no] &lt; r_track[step_no - 1]:
                    theta.append(
                        theta[-1]
                        - math.pi
                        + math.asin(
                            r_track[step_no - 1]
                            * math.sin(math.acos(mu_track[step_no - 1]))
                            / r_track[step_no]
                        )
                        + math.acos(mu_track[step_no - 1])
                    )
                else:
                    theta.append(
                        theta[-1]
                        + math.asin(
                            -1
                            * r_track[step_no - 1]
                            * math.sin(math.acos(mu_track[step_no - 1]))
                            / r_track[step_no]
                        )
                        + math.acos(mu_track[step_no - 1])
                    )

        # converting the thetas into x and y coordinates using radius as radius*cos(theta) and radius*sin(theta) respectively
        rpacket_x = (np.array(r_track)) * np.cos(np.array(theta)) * 1e-5 / time
        rpacket_y = (np.array(r_track)) * np.sin(np.array(theta)) * 1e-5 / time

        # adding interactions at different steps
        # using the change of slope of the trajectory line at different steps, we determine if an interactions happened or not.

        for step_no in range(len(r_track)):
            # when packet is at its starting and ending point in its trajectory, we consider it as no interaction
            if step_no == 0 or step_no == len(r_track) - 1:
                rpacket_interactions.append(0)
            else:
                # current slope is the slope of line from previous position of the packet to the current position
                current_slope = (
                    rpacket_y[step_no] - rpacket_y[step_no - 1]
                ) / (rpacket_x[step_no] - rpacket_x[step_no - 1])
                # next slope is the slope of line from current position of the packet to the next position
                next_slope = (rpacket_y[step_no + 1] - rpacket_y[step_no]) / (
                    rpacket_x[step_no + 1] - rpacket_x[step_no]
                )
                # here if the slope changes significantly we say, its an interaction
                if math.isclose(current_slope, next_slope, rel_tol=1e-10):
                    rpacket_interactions.append(0)
                else:
                    rpacket_interactions.append(last_interaction_type[step_no])

        return rpacket_x, rpacket_y, rpacket_interactions</div>

<div class="viewcode-block" id="RPacketPlotter.get_coordinates_multiple_packets"><a class="viewcode-back" href="../../../../api/tardis.visualization.tools.rpacket_visualization.html#tardis.visualization.tools.rpacket_visualization.RPacketPlotter.get_coordinates_multiple_packets">[docs]</a>    def get_coordinates_multiple_packets(self, r_packet_tracker):
        &quot;&quot;&quot;
        Generates an array of array containing x and y coordinates of multiple packets

        Parameters
        ----------
        r_packet_tracker : pandas.core.frame.DataFrame
            contains the rpacket_tracker_df dataframe with data of only specified no_of_packets

        Returns
        -------
        numpy.ndarray
            array of array containing x coordinates, y coordinates and the interactions for multiple packets
        &quot;&quot;&quot;

        # for plotting packets at equal intervals throught the circle, we choose thetas distributed uniformly
        thetas = np.linspace(0, 2 * math.pi, self.no_of_packets + 1)
        rpackets_x = []
        rpackets_y = []
        rpackets_interactions = []
        # getting coordinates and interaction arrays for all packets
        for packet_no in range(self.no_of_packets):
            (
                rpacket_x,
                rpacket_y,
                rpacket_interactions,
            ) = self.get_coordinates_with_theta_init(
                r_packet_tracker.loc[packet_no][&quot;r&quot;],
                r_packet_tracker.loc[packet_no][&quot;mu&quot;],
                self.sim.model.time_explosion.value,
                r_packet_tracker.loc[packet_no][&quot;interaction_type&quot;],
                thetas[packet_no],
            )
            rpackets_x.append(rpacket_x)
            rpackets_y.append(rpacket_y)
            rpackets_interactions.append(rpacket_interactions)
        return (
            np.array(rpackets_x, dtype=&quot;object&quot;),
            np.array(rpackets_y, dtype=&quot;object&quot;),
            np.array(rpackets_interactions, dtype=&quot;object&quot;),
        )</div>

<div class="viewcode-block" id="RPacketPlotter.get_equal_array_size"><a class="viewcode-back" href="../../../../api/tardis.visualization.tools.rpacket_visualization.html#tardis.visualization.tools.rpacket_visualization.RPacketPlotter.get_equal_array_size">[docs]</a>    def get_equal_array_size(self, rpacket_x, rpacket_y, interactions):
        &quot;&quot;&quot;
        creates the coordinate arrays of different packets of same size. This is done for generating frames in animation.

        Parameters
        ----------
        rpacket_x : numpy.ndarray
            x coordinates of packets
        rpacket_y : numpy.ndarray
            y coordinates of packets
        interactions : numpy.ndarray
            interaction types of packets

        Returns
        -------
        numpy.ndarray
            normalized x coordinate array
        numpy.ndarray
            normalized y coordinate array
        numpy.ndarray
            normalized interaction types array
        int
            size of the biggest array among different packets

        &quot;&quot;&quot;
        rpacket_step_no_array_max_size = max(list(map(len, rpacket_x)))

        for packet_no in range(len(rpacket_x)):
            # making all coordinate arrays of size `rpacket_step_no_array_max_size` by repeating the last element across the remaining length of array
            rpacket_x[packet_no] = np.append(
                rpacket_x[packet_no],
                rpacket_x[packet_no][-1]
                * np.ones(
                    [rpacket_step_no_array_max_size - len(rpacket_x[packet_no])]
                ),
            )
            rpacket_y[packet_no] = np.append(
                rpacket_y[packet_no],
                rpacket_y[packet_no][-1]
                * np.ones(
                    [rpacket_step_no_array_max_size - len(rpacket_y[packet_no])]
                ),
            )
            interactions[packet_no] = np.append(
                interactions[packet_no],
                interactions[packet_no][-1]
                * np.ones(
                    [
                        rpacket_step_no_array_max_size
                        - len(interactions[packet_no])
                    ]
                ),
            )
        return (
            rpacket_x,
            rpacket_y,
            interactions,
            rpacket_step_no_array_max_size,
        )</div>

    # creating frames for animation
<div class="viewcode-block" id="RPacketPlotter.get_frames"><a class="viewcode-back" href="../../../../api/tardis.visualization.tools.rpacket_visualization.html#tardis.visualization.tools.rpacket_visualization.RPacketPlotter.get_frames">[docs]</a>    def get_frames(self, frame, rpacket_x, rpacket_y, interactions, theme):
        &quot;&quot;&quot;
        Creates individual frames containing the go.Scatter objects for the animation.

        Parameters
        ----------
        frame : int
            current frame number
        rpacket_x : numpy.ndarray
            x coordinates array
        rpacket_y : numpy.ndarray
            y coordinates array
        interactions : numpy.ndarray
            interactions array
        theme : str
            theme for the plot

        Returns
        -------
        list
            list of go.Scatter objects for a particular frame number.
        &quot;&quot;&quot;
        frames = []
        for packet_no in range(len(rpacket_x)):
            frames.append(
                go.Scatter(
                    x=rpacket_x[packet_no].tolist()[0:frame],
                    y=rpacket_y[packet_no].tolist()[0:frame],
                    mode=&quot;markers+lines&quot;,
                    name=&quot;Packet &quot; + str(packet_no + 1),
                    showlegend=False,
                    hovertemplate=&quot;&lt;b&gt;X&lt;/b&gt;: %{x}&quot;
                    + &quot;&lt;br&gt;&lt;b&gt;Y&lt;/b&gt;: %{y}&lt;br&gt;&quot;
                    + &quot;&lt;b&gt;Last Interaction: %{text}&lt;/b&gt;&quot;,
                    text=[
                        self.interaction_from_num[
                            int(interactions[packet_no][step_no])
                        ][&quot;text&quot;]
                        for step_no in range(len(rpacket_x[packet_no]))
                    ],
                    line=dict(
                        color=self.theme_colors[theme][&quot;packet_line_color&quot;]
                    ),
                    marker=dict(
                        opacity=[
                            self.interaction_from_num[
                                int(interactions[packet_no][step_no])
                            ][&quot;opacity&quot;]
                            for step_no in range(len(rpacket_x[packet_no]))
                        ],
                        color=[
                            self.interaction_from_num[
                                int(interactions[packet_no][step_no])
                            ][&quot;color&quot;]
                            for step_no in range(len(rpacket_x[packet_no]))
                        ],
                    ),
                )
            )
        return frames</div>

    # creating steps for the timeline slider
<div class="viewcode-block" id="RPacketPlotter.get_slider_steps"><a class="viewcode-back" href="../../../../api/tardis.visualization.tools.rpacket_visualization.html#tardis.visualization.tools.rpacket_visualization.RPacketPlotter.get_slider_steps">[docs]</a>    def get_slider_steps(self, rpacket_max_array_size):
        &quot;&quot;&quot;
        Generates different steps in the timeline slider for different frames in the animated plot.

        Parameters
        ----------
        rpacket_max_array_size : int
            maximum size of coordinate array among all the packets.

        Returns
        -------
        list
            list of dictionaries of different steps for different frames.
        &quot;&quot;&quot;

        slider_steps = []
        for step_no in range(rpacket_max_array_size):
            slider_steps.append(
                {
                    &quot;args&quot;: [
                        [step_no],
                        {
                            &quot;frame&quot;: {&quot;duration&quot;: 300, &quot;redraw&quot;: False},
                            &quot;mode&quot;: &quot;immediate&quot;,
                            &quot;transition&quot;: {&quot;duration&quot;: 300},
                        },
                    ],
                    &quot;label&quot;: step_no,
                    &quot;method&quot;: &quot;animate&quot;,
                }
            )

        return slider_steps</div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2022, TARDIS Collaboration.
      <span class="lastupdated">Last updated on 06 Sep 2022.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>