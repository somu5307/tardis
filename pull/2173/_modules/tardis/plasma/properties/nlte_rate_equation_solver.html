<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tardis.plasma.properties.nlte_rate_equation_solver &mdash; tardis</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/plot_directive.css" type="text/css" />
    <link rel="shortcut icon" href="../../../../_static/tardis_logo.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href="../../../../_static/tardis.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> tardis
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart.html">Quickstart for TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/modules.html">API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Input/Output</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/configuration/index.html">Configuration (Required Input)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/optional/index.html">Optional Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/visualization/index.html">Visualization Tools &amp; Widgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/output/index.html">Additional Outputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/grid/TardisGridTutorial.html">Running TARDIS Model Grids</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Physics Walkthrough</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/intro/index.html">Physics Walkthrough Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/setup/index.html">Setting Up the Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/montecarlo/index.html">Monte Carlo Iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/update_and_conv/update_and_conv.html">Updating Plasma and Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../physics/spectrum/index.html">Spectrum Generation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing to TARDIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/CONTRIBUTING.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/development/index.html">Developer Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/tools/index.html">Developer Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/CHANGELOG.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing/in_progress/index.html">Features In-Progress</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/credits.html">Credits &amp; Publication Policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/research_done_using_TARDIS/research_papers.html">Papers Using TARDIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/code_comparison/index.html">Code Comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../resources/zreferences.html">References and Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">tardis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tardis.plasma.properties.nlte_rate_equation_solver</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tardis.plasma.properties.nlte_rate_equation_solver</h1><div class="highlight"><pre>
<span></span>import pandas as pd
import numpy as np

from tardis.plasma.properties.base import ProcessingPlasmaProperty

__all__ = [
    &quot;NLTERateEquationSolver&quot;,
]


<div class="viewcode-block" id="NLTERateEquationSolver"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver">[docs]</a>class NLTERateEquationSolver(ProcessingPlasmaProperty):
    outputs = (&quot;ion_number_density_nlte&quot;, &quot;electron_densities_nlte&quot;)

<div class="viewcode-block" id="NLTERateEquationSolver.calculate"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.calculate">[docs]</a>    def calculate(
        self,
        gamma,
        alpha_sp,
        alpha_stim,
        coll_ion_coeff,
        coll_recomb_coeff,
        partition_function,
        levels,
        level_boltzmann_factor,
        phi,
        rate_matrix_index,
        number_density,
    ):
        &quot;&quot;&quot;Calculates ion number densities and electron densities using NLTE ionization.

        Parameters
        ----------
        gamma : DataFrame
            The rate coefficient for radiative ionization.
        alpha_sp : DataFrame
            The rate coefficient for spontaneous recombination.
        alpha_stim : DataFrame
            The rate coefficient for stimulated recombination.
        coll_ion_coeff : DataFrame
            The rate coefficient for collisional ionization in the Seaton
            approximation.
        coll_recomb_coeff : DataFrame
            The rate coefficient for collisional recombination.
        partition_function : DataFrame
            General partition function. Indexed by atomic number, ion number.
        levels : MultiIndex
            (atomic_number, ion_number, level_number)
            Index of filtered atomic data.
        level_boltzmann_factor : DataFrame
            General Boltzmann factor.
        phi : DataFrame
            Saha Factors.
        rate_matrix_index : MultiIndex
            (atomic_number, ion_number, treatment type)
            If ion is treated in LTE or nebular ionization, 3rd index is &quot;lte_ion&quot;,
            if treated in NLTE ionization, 3rd index is &quot;nlte_ion&quot;.
        number_density : DataFrame
            Number density in each shell for each species.

        Returns
        -------
        ion_number_densities_nlte : DataFrame
            Number density with NLTE ionization treatment.
        electron_densities_nlte : Series
            Electron density with NLTE ionization treatment.
        &quot;&quot;&quot;

        (
            total_photo_ion_coefficients,
            total_rad_recomb_coefficients,
            total_coll_ion_coefficients,
            total_coll_recomb_coefficients,
        ) = self.prepare_ion_recomb_coefficients_nlte_ion(
            gamma,
            alpha_sp,
            alpha_stim,
            coll_ion_coeff,
            coll_recomb_coeff,
            partition_function,
            levels,
            level_boltzmann_factor,
        )

        # &gt;&gt;&gt;TODO:initial electron density should be included in the initial guess, added in a future PR
        initial_electron_density = number_density.sum(axis=0)
        # &lt;&lt;&lt;
        atomic_numbers = (
            rate_matrix_index.get_level_values(&quot;atomic_number&quot;)
            .unique()
            .drop(&quot;n_e&quot;)
        )  # dropping the n_e index, as rate_matrix_index&#39;s first index is (atomic_numbers, &quot;n_e&quot;)
        rate_matrix = self.calculate_rate_matrix(
            atomic_numbers,
            phi[0],
            initial_electron_density[0],
            rate_matrix_index,
            total_photo_ion_coefficients[0],
            total_rad_recomb_coefficients[0],
            total_coll_ion_coefficients[0],
            total_coll_recomb_coefficients[0],
        )
        initial_guess = self.prepare_first_guess(
            atomic_numbers, number_density[0], initial_electron_density[0]
        )
        jacobian_matrix = self.jacobian_matrix(
            atomic_numbers,
            initial_guess,
            rate_matrix,
            rate_matrix_index,
            total_rad_recomb_coefficients[0],
            total_coll_ion_coefficients[0],
            total_coll_recomb_coefficients[0],
        )
        # TODO: change the jacobian and rate matrix to use shell id and get coefficients from the attribute of the class.

        raise NotImplementedError(
            &quot;NLTE ionization hasn&#39;t been fully implemented yet!&quot;
        )</div>

<div class="viewcode-block" id="NLTERateEquationSolver.calculate_rate_matrix"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.calculate_rate_matrix">[docs]</a>    @staticmethod
    def calculate_rate_matrix(
        atomic_numbers,
        phi_shell,
        electron_density,
        rate_matrix_index,
        total_photo_ion_coefficients,
        total_rad_recomb_coefficients,
        total_coll_ion_coefficients,
        total_coll_recomb_coefficients,
    ):
        &quot;&quot;&quot;

        Parameters
        ----------
        phi_shell : DataFrame
            Saha Factors in the current shell
        electron_density : float
            Guess for electron density in the current shell
        rate_matrix_index : MultiIndex
            Index used for constructing the rate matrix
        total_photo_ion_coefficients : DataFrame
            Photo ionization coefficients
        total_rad_recomb_coefficients : DataFrame
            Radiative recombination coefficients (should get multiplied by electron density)
        total_coll_ion_coefficients : DataFrame
            Collisional ionization coefficients (should get multiplied by electron density)
        total_coll_recomb_coefficients : DataFrame
            Collisional recombination coefficients (should get multiplied by electron density^2)

        Returns
        -------
        DataFrame
            Rate matrix used for NLTE solver.
        &quot;&quot;&quot;
        rate_matrix = pd.DataFrame(
            0.0, columns=rate_matrix_index, index=rate_matrix_index
        )
        total_rad_recomb_coefficients = (
            total_rad_recomb_coefficients * electron_density
        )
        total_coll_ion_coefficients = (
            total_coll_ion_coefficients * electron_density
        )
        total_coll_recomb_coefficients = (
            total_coll_recomb_coefficients * electron_density**2
        )
        for atomic_number in atomic_numbers:
            ion_numbers = rate_matrix.loc[atomic_number].index.get_level_values(
                &quot;ion_number&quot;
            )
            phi_block = phi_shell.loc[atomic_number]
            rate_matrix_block = NLTERateEquationSolver.lte_rate_matrix_block(
                phi_block, electron_density
            )

            nlte_ion_numbers = ion_numbers[
                rate_matrix.loc[atomic_number].index.get_level_values(
                    &quot;level_number&quot;
                )
                == &quot;nlte_ion&quot;
            ]
            # &gt;&gt;&gt; lte_ion_numbers is for future use in NLTE excitation treatment
            lte_ion_numbers = ion_numbers[
                rate_matrix.loc[atomic_number].index.get_level_values(
                    &quot;level_number&quot;
                )
                == &quot;lte_ion&quot;
            ]
            # &lt;&lt;&lt;
            for ion_number in nlte_ion_numbers:
                rate_matrix_block = NLTERateEquationSolver.set_nlte_ion_rate(
                    rate_matrix_block,
                    atomic_number,
                    ion_number,
                    total_rad_recomb_coefficients.loc[(atomic_number,)],
                    total_photo_ion_coefficients.loc[(atomic_number,)],
                    total_coll_ion_coefficients.loc[(atomic_number,)],
                    total_coll_recomb_coefficients.loc[(atomic_number,)],
                )
            rate_matrix.loc[
                (atomic_number, slice(None)), (atomic_number)
            ] = rate_matrix_block

        charge_conservation_row = (
            NLTERateEquationSolver.prepare_charge_conservation_row(
                atomic_numbers
            )
        )
        rate_matrix.loc[(&quot;n_e&quot;, slice(None))] = charge_conservation_row
        return rate_matrix</div>

<div class="viewcode-block" id="NLTERateEquationSolver.set_nlte_ion_rate"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.set_nlte_ion_rate">[docs]</a>    @staticmethod
    def set_nlte_ion_rate(
        rate_matrix_block,
        atomic_number,
        ion_number,
        total_rad_recomb_coefficients,
        total_photo_ion_coefficients,
        total_coll_ion_coefficients,
        total_coll_recomb_coefficients,
    ):
        &quot;&quot;&quot;Calculates the row for the species treated in NLTE ionization

        Parameters
        ----------
        rate_matrix_block : numpy.array
            The diagonal block corresponding to current atomic number.
        atomic_number : int
            Current atomic number
        ion_number : int
            Current ion number
        total_rad_recomb_coefficients : DataFrame
            Rad. recomb. coefficients for current atomic number
        total_photo_ion_coefficients : DataFrame
            Photo ion. coefficients for current atomic number
        total_coll_ion_coefficients : DataFrame
            Coll. ion. coefficients for current atomic number
        total_coll_recomb_coefficients : DataFrame
            Coll. recomb. coefficients for current atomic number

        Returns
        -------
        numpy.array
            Rate matrix block with a changed row for NLTE ionization treatment
        &quot;&quot;&quot;
        ion_coefficients = (
            total_photo_ion_coefficients + total_coll_ion_coefficients
        )
        recomb_coefficients = (
            total_rad_recomb_coefficients + total_coll_recomb_coefficients
        )
        if atomic_number != ion_number:
            ion_coeff_matrix_ion_row = NLTERateEquationSolver.ion_matrix(
                ion_coefficients, atomic_number, ion_number
            )
            recomb_coeff_matrix_ion_row = NLTERateEquationSolver.recomb_matrix(
                recomb_coefficients, atomic_number, ion_number
            )
            rate_matrix_block[ion_number, :] = (
                ion_coeff_matrix_ion_row + recomb_coeff_matrix_ion_row
            )
        return rate_matrix_block</div>

<div class="viewcode-block" id="NLTERateEquationSolver.lte_rate_matrix_block"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.lte_rate_matrix_block">[docs]</a>    @staticmethod
    def lte_rate_matrix_block(phi_block, electron_density):
        &quot;&quot;&quot;Creates the generic LTE block for rate matrix.

        Parameters
        ----------
        phi_block : DataFrame
            Saha Factors for current atomic number
        electron_density : float
            Current guess for electron density

        Returns
        -------
        numpy.array
            LTE block for rate matrix
        &quot;&quot;&quot;
        lte_rate_vector_block = -1.0 * np.hstack([*phi_block.values, -1.0])
        lte_rate_matrix_block = np.diag(lte_rate_vector_block)
        n_e_initial = np.ones(len(phi_block)) * electron_density
        n_e_matrix = np.diag(n_e_initial, 1)
        lte_rate_matrix_block += n_e_matrix
        lte_rate_matrix_block[-1, :] = 1.0
        return lte_rate_matrix_block</div>

<div class="viewcode-block" id="NLTERateEquationSolver.prepare_phi"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.prepare_phi">[docs]</a>    @staticmethod
    def prepare_phi(phi):
        &quot;&quot;&quot;
        Makes sure that phi does not have any 0 entries.
        &quot;&quot;&quot;
        phi[phi == 0.0] = 1.0e-10 * phi[phi &gt; 0.0].min().min()
        return phi</div>

<div class="viewcode-block" id="NLTERateEquationSolver.recomb_matrix"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.recomb_matrix">[docs]</a>    @staticmethod
    def recomb_matrix(recomb_coefficients, atomic_number, ion_number):
        &quot;&quot;&quot;Constructs a recombination rate matrix from the recombination rates.

        Parameters
        ----------
        recomb_coefficients : DataFrame
            Recombination coefficients.
        atomic_number : int64
            Current atomic number. Used for the dimension of a square matrix.
        ion_number : int64
            Current ion number. Used for returning the correct row.

        Returns
        -------
        numpy.ndarray
        &quot;&quot;&quot;
        offdiag = np.zeros(atomic_number)
        index = recomb_coefficients.index
        for i in index:
            offdiag[i] = recomb_coefficients.loc[i]
        diag = np.hstack([np.zeros(1), -offdiag])
        return (np.diag(diag) + np.diag(offdiag, k=1))[ion_number, :]</div>

<div class="viewcode-block" id="NLTERateEquationSolver.ion_matrix"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.ion_matrix">[docs]</a>    @staticmethod
    def ion_matrix(ion_coefficients, atomic_number, ion_number):
        &quot;&quot;&quot;Constructs an ionization rate matrix from the ionization rates.

        Parameters
        ----------
        ion_coefficients : DataFrame
            Recombination coefficients.
        atomic_number : int64
            Current atomic number. Used for the dimension of a square matrix.
        ion_number : int64
            Current ion number. Used for returning the correct row.

        Returns
        -------
        numpy.ndarray
        &quot;&quot;&quot;
        offdiag = np.zeros(atomic_number)
        index = ion_coefficients.index
        for i in index:
            offdiag[i] = ion_coefficients.loc[i]
        diag = np.hstack([-offdiag, np.zeros(1)])
        return (np.diag(diag) + np.diag(offdiag, k=-1))[ion_number, :]</div>

<div class="viewcode-block" id="NLTERateEquationSolver.prepare_charge_conservation_row"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.prepare_charge_conservation_row">[docs]</a>    @staticmethod
    def prepare_charge_conservation_row(atomic_numbers):
        &quot;&quot;&quot;Prepares the last row of the rate_matrix. This row corresponds to the charge
        density equation.&quot;&quot;&quot;
        charge_conservation_row = []
        for atomic_number in atomic_numbers:
            charge_conservation_row.append(np.arange(0, atomic_number + 1))
        charge_conservation_row = np.hstack([*charge_conservation_row, -1])
        # TODO needs to be modified for use in nlte_excitation
        return charge_conservation_row</div>

<div class="viewcode-block" id="NLTERateEquationSolver.prepare_ion_recomb_coefficients_nlte_ion"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.prepare_ion_recomb_coefficients_nlte_ion">[docs]</a>    @staticmethod
    def prepare_ion_recomb_coefficients_nlte_ion(
        gamma,
        alpha_sp,
        alpha_stim,
        coll_ion_coeff,
        coll_recomb_coeff,
        partition_function,
        levels,
        level_boltzmann_factor,
    ):
        &quot;&quot;&quot;
        Prepares the ionization and recombination coefficients by grouping them for
        ion numbers.

        Parameters
        ----------
        gamma : DataFrame
            The rate coefficient for radiative ionization.
        alpha_sp : DataFrame
            The rate coefficient for spontaneous recombination.
        alpha_stim : DataFrame
            The rate coefficient for stimulated recombination.
        coll_ion_coeff : DataFrame
            The rate coefficient for collisional ionization in the Seaton
            approximation.
        coll_recomb_coeff : DataFrame
            The rate coefficient for collisional recombination.
        partition_function : DataFrame
            General partition function. Indexed by atomic number, ion number.
        levels : MultiIndex
            (atomic_number, ion_number, level_number)
            Index of filtered atomic data.
        level_boltzmann_factor : DataFrame
            General Boltzmann factor.
        Returns
        -------
        total_photo_ion_coefficients
            Photoionization coefficients grouped by atomic number and ion number.
        total_rad_recomb_coefficients
            Radiative recombination coefficients grouped by atomic number and ion number.
        total_coll_ion_coefficients
            Collisional ionization coefficients grouped by atomic number and ion number.
        total_coll_recomb_coefficients
            Collisional recombination coefficients grouped by atomic number and ion number.
        &quot;&quot;&quot;
        indexer = pd.Series(
            np.arange(partition_function.shape[0]),
            index=partition_function.index,
        )
        _ion2level_idx = indexer.loc[levels.droplevel(&quot;level_number&quot;)].values
        partition_function_broadcast = partition_function.values[_ion2level_idx]
        level_population_fraction = pd.DataFrame(
            level_boltzmann_factor.values / partition_function_broadcast,
            index=levels,
        )
        total_photo_ion_coefficients = (
            (level_population_fraction.loc[gamma.index] * gamma)
            .groupby(level=(&quot;atomic_number&quot;, &quot;ion_number&quot;))
            .sum()
        )
        total_rad_recomb_coefficients = (
            (alpha_sp + alpha_stim)
            .groupby(level=[&quot;atomic_number&quot;, &quot;ion_number&quot;])
            .sum()
        )
        total_coll_ion_coefficients = (
            (
                level_population_fraction.loc[coll_ion_coeff.index]
                * coll_ion_coeff
            )
            .groupby(level=(&quot;atomic_number&quot;, &quot;ion_number&quot;))
            .sum()
        )
        total_coll_recomb_coefficients = (
            (coll_recomb_coeff)
            .groupby(level=(&quot;atomic_number&quot;, &quot;ion_number&quot;))
            .sum()
        )
        return (
            total_photo_ion_coefficients,
            total_rad_recomb_coefficients,
            total_coll_ion_coefficients,
            total_coll_recomb_coefficients,
        )</div>

<div class="viewcode-block" id="NLTERateEquationSolver.jacobian_matrix"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.jacobian_matrix">[docs]</a>    @staticmethod
    def jacobian_matrix(
        atomic_numbers,
        populations,
        rate_matrix,
        rate_matrix_index,
        total_rad_recomb_coefficients,
        total_coll_ion_coefficients,
        total_coll_recomb_coefficients,
    ):
        &quot;&quot;&quot;Creates the jacobian matrix used for NLTE ionization solver

        Parameters
        ----------
        populations : numpy.array
            Ion populations, electron density
        rate_matrix : DataFrame
            Rate matrix used for NLTE solver.
        rate_matrix_index : MultiIndex
            (atomic_number, ion_number, treatment type)
            If ion is treated in LTE or nebular ionization, 3rd index is &quot;lte_ion&quot;,
            if treated in NLTE ionization, 3rd index is &quot;nlte_ion&quot;.
        total_rad_recomb_coefficients : DataFrame
            Radiative recombination coefficients grouped by atomic number and ion number.
        total_coll_ion_coefficients : DataFrame
            Collisional ionization coefficients(should get multiplied by electron density).
        total_coll_recomb_coefficients : DataFrame
            Collisional recombination coefficients(should get multiplied by electron density).

        Returns
        -------
        numpy.array
            Jacobian matrix used for NLTE ionization solver
        &quot;&quot;&quot;
        # TODO: for future use, can be vectorized.
        index = 0
        jacobian_matrix = rate_matrix.copy().values
        jacobian_matrix[:-1, -1] = populations[1:]
        for atomic_number in atomic_numbers:
            for i in range(index, index + atomic_number):
                if rate_matrix_index[i][2] == &quot;nlte_ion&quot;:
                    jacobian_matrix[
                        i, -1
                    ] = NLTERateEquationSolver.deriv_matrix_block(
                        atomic_number,
                        total_rad_recomb_coefficients.loc[(atomic_number,)],
                        total_coll_ion_coefficients.loc[(atomic_number,)],
                        total_coll_recomb_coefficients.loc[(atomic_number,)],
                        populations[index : index + atomic_number + 1],
                        populations[-1],
                    )[
                        i - index
                    ]
            index += atomic_number + 1
            jacobian_matrix[index - 1, -1] = 0  # number conservation row
        return jacobian_matrix</div>

<div class="viewcode-block" id="NLTERateEquationSolver.deriv_matrix_block"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.deriv_matrix_block">[docs]</a>    @staticmethod
    def deriv_matrix_block(
        atomic_number,
        total_rad_recomb_coefficients,
        total_coll_ion_coefficients,
        total_coll_recomb_coefficients,
        current_ion_number_densities,
        current_electron_density,
    ):
        &quot;&quot;&quot;Calculates the dot product of the derivative of rate matrix and ion number densities+electron density column.

        Parameters
        ----------
        atomic_number : int64
            Current atomic number
        total_rad_recomb_coefficients : DataFrame
            Radiative recombination coefficients grouped by atomic number and ion number.
        total_coll_ion_coefficients : DataFrame
            Collisional ionization coefficients.
        total_coll_recomb_coefficients : DataFrame
            Collisional recombination coefficients.
        current_ion_number_densities : numpy.array
            Current ion number densities for the current atomic number.
        current_electron_density : float64
            Current electron density

        Returns
        -------
        numpy.array
            Returns the part of the last column of the jacobian matrix, corresponding to atomic number.
        &quot;&quot;&quot;
        ion_numbers = np.arange(0, atomic_number)
        radiative_rate_coeff_matrix = NLTERateEquationSolver.recomb_matrix(
            total_rad_recomb_coefficients, atomic_number, ion_numbers
        )
        coll_recomb_matrix = (
            NLTERateEquationSolver.recomb_matrix(
                total_coll_recomb_coefficients, atomic_number, ion_numbers
            )
            * current_electron_density
            * 2
        )
        coll_ion_coeff_matrix = NLTERateEquationSolver.ion_matrix(
            total_coll_ion_coefficients, atomic_number, ion_numbers
        )
        deriv_matrix = (
            radiative_rate_coeff_matrix
            + coll_ion_coeff_matrix
            + coll_recomb_matrix
        )
        return np.dot(deriv_matrix, current_ion_number_densities)</div>

<div class="viewcode-block" id="NLTERateEquationSolver.prepare_first_guess"><a class="viewcode-back" href="../../../../api/tardis.plasma.properties.nlte_rate_equation_solver.html#tardis.plasma.properties.nlte_rate_equation_solver.NLTERateEquationSolver.prepare_first_guess">[docs]</a>    def prepare_first_guess(
        self, atomic_numbers, number_density, electron_density
    ):
        # TODO needs to be changed for excitation
        array_size = (number_density.index.values + 1).sum() + 1
        first_guess = np.zeros(array_size)
        index = 1
        for atomic_number in atomic_numbers:
            first_guess[index] = number_density.loc[atomic_number]
            index += atomic_number + 1
        first_guess[-1] = electron_density
        return first_guess</div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2013-2022, TARDIS Collaboration.
      <span class="lastupdated">Last updated on 12 Dec 2022.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>